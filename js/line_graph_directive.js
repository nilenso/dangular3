// Generated by CoffeeScript 1.3.3
(function() {

  angular.module("App").directive("d3LineGraph", function() {
    return {
      restrict: "E",
      scope: {
        data: "="
      },
      link: function(scope, element, attrs) {
        var bisectDate, color, height, line, margin, metric, metrics, parseDate, svg, tooltip, width, x, xAxis, y, yAxis, yValue;
        margin = {
          top: 30,
          right: 30,
          bottom: 30,
          left: 30
        };
        width = (parseInt(attrs.width) || 960) - margin.left - margin.right;
        height = (parseInt(attrs.height) || 500) - margin.top - margin.bottom;
        parseDate = d3.time.format("%Y-%m-%d").parse;
        scope.data.forEach(function(d) {
          return d.date = parseDate(d.date);
        });
        bisectDate = d3.bisector(function(d) {
          return d.date;
        }).left;
        yValue = function(x0) {
          var d0, d1, i;
          i = bisectDate(scope.data, x0, 1);
          d0 = scope.data[i - 1];
          d1 = scope.data[i];
          if (x0 - d0.date > d1.date - x0) {
            return d1;
          } else {
            return d0;
          }
        };
        x = d3.time.scale().range([0, width]);
        y = d3.scale.linear().range([height, 0]);
        xAxis = d3.svg.axis().scale(x).orient("bottom");
        yAxis = d3.svg.axis().scale(y).orient("left");
        color = d3.scale.category10();
        line = d3.svg.line().interpolate("basis").x(function(d) {
          return x(d.date);
        }).y(function(d) {
          return y(d.metricValue);
        });
        svg = d3.select(element[0]).append("svg").attr("width", width + margin.left + margin.right).attr("height", height + margin.top + margin.bottom).append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
        color.domain(d3.keys(scope.data[0]).filter(function(key) {
          return key !== "date";
        }));
        metrics = color.domain().map(function(name) {
          return {
            name: name,
            values: scope.data.map(function(d) {
              return {
                date: d.date,
                metricValue: +d[name]
              };
            })
          };
        });
        x.domain(d3.extent(scope.data, function(d) {
          return d.date;
        }));
        y.domain([
          d3.min(metrics, function(c) {
            return d3.min(c.values, function(v) {
              return v.metricValue;
            });
          }), d3.max(metrics, function(c) {
            return d3.max(c.values, function(v) {
              return v.metricValue;
            });
          })
        ]);
        svg.append("g").attr("class", "x axis").attr("transform", "translate(0," + height + ")").call(xAxis);
        svg.append("g").attr("class", "y axis").call(yAxis);
        tooltip = d3.select("body").append("span").attr("class", "graph-tooltip").style("opacity", 0);
        metric = svg.selectAll(".metric").data(metrics).enter().append("g").attr("class", "metric");
        return metric.append("path").attr("d", function(d) {
          return line(d.values);
        }).attr("class", function(d) {
          return "line " + d.name;
        }).on("mouseover", function(d) {
          var x0;
          x0 = x.invert(d3.mouse(this)[0]);
          tooltip;

          return tooltip.html(yValue(x0)[d.name]).style("left", d3.event.pageX + "px").style("top", (d3.event.pageY - 28) + "px").style("opacity", .8);
        }).on("mouseout", function(d) {
          return tooltip.style("opacity", 0);
        });
      }
    };
  });

}).call(this);
